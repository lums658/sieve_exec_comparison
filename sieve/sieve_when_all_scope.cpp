/**
 * @file sieve_unifex_fun.cpp
 *
 * @section LICENSE
 *
 * The MIT License
 *
 * @copyright Copyright (c) 2022 TileDB, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * @section DESCRIPTION
 *
 * Demo program for libunifex: Sieve of Eratosthenes,
 * free function version.
 */






#include <unifex/async_scope.hpp>
#include <unifex/async_manual_reset_event.hpp>
#include <unifex/sync_wait.hpp>
#include <unifex/just_done.hpp>
#include <unifex/just_error.hpp>
#include <unifex/just.hpp>
#include <unifex/sequence.hpp>
#include <unifex/just_void_or_done.hpp>
#include <unifex/let_done.hpp>
#include <unifex/let_error.hpp>
#include <unifex/let_value.hpp>
#include <unifex/let_value_with.hpp>
#include <unifex/static_thread_pool.hpp>
#include <unifex/task.hpp>
#include <unifex/then.hpp>
#include <unifex/when_all.hpp>

#include <atomic>
#include <cmath>
#include <functional>
#include <iostream>
#include <thread>

#include "sieve.hpp"
#include "sieve_fun.hpp"
#include "timer.hpp"

using namespace std::placeholders;
using namespace unifex;


/**
 * @brief Generate primes from 2 to n using sieve of Eratosthenes.
 * @tparam bool_t the type to use for the "bitmap"
 * @param n upper bound of sieve
 * @param block_size how many primes to search for given a base set of primes
 */
template <class bool_t>
auto sieve_unifex_block(size_t n, size_t block_size) {
  size_t sqrt_n = static_cast<size_t>(std::ceil(std::sqrt(n)));

  /* Generate base set of sqrt(n) primes to be used for subsequent sieving */
  auto first_sieve = sieve_seq<bool_t>(sqrt_n);
  std::vector<size_t> base_primes = sieve_to_primes(first_sieve);

  /* Store vector of list of primes (each list generated by separate task chain) */
  std::vector<std::shared_ptr<std::vector<size_t>>> prime_list(n / block_size + 2);
  prime_list[0] = std::make_shared<std::vector<size_t>>(base_primes);

  namespace ex = unifex;

  /**
   * Build pipeline
   */
  auto bod = input_body{};
  auto l = [&bod]() mutable noexcept { return bod(); };
  
  auto make_snd = [&]() {

    ex::sender auto snd =
      ex::just() |
      ex::then(l) |
      ex::then(std::bind(gen_range<bool_t>, _1, block_size, sqrt_n, n)) |
      ex::then(std::bind(range_sieve<bool_t>, _1, cref(base_primes))) |
      ex::then(sieve_to_primes_part<bool_t>) |
      ex::then(std::bind(output_body, _1, ref(prime_list))) |
      ex::then([](){return 0;});;
    
    return snd;
  };


#if 0
  ex::async_scope scope;

  /* launch tasks on async_scope */
  for (size_t i = 0; i < n / block_size + 1; ++i) {
    scope.spawn_on(pool.get_scheduler(), make_snd());
  }

  /* wait for tasks to finish */
  ex::sync_wait(scope.complete());
#else


  unifex::static_thread_pool pool{std::thread::hardware_concurrency()};

    auto when_all_iterator = [&pool](auto first, auto last) {
        using Iterator = decltype(first);
        struct Data {
            Data(Iterator first, Iterator last)
                : first(first)
                , last(last)
                , n(std::distance(first, last))
                , counter{n}
                , resultStorage(n)
            { }

            Iterator first, last;
            size_t n;
            std::atomic<size_t> counter;
            std::vector<std::optional<int>> resultStorage;
            async_manual_reset_event evt;
            std::optional<std::exception_ptr> error;
            std::atomic<bool> doneOrError{false};
            async_scope scope;
        };

        return let_value_with([&pool, first, last]() {
                return Data(first, last);
            }, [&pool](Data& data) {

	      auto signal = [&data,&pool]() {
                if (data.counter.fetch_sub(1) == 1) {
                    data.evt.set();
                }
                assert(data.counter >= 0);
            };

            size_t i = 0;
            for (auto itr = data.first; itr != data.last; ++i, ++itr) {
	      data.scope.spawn_on(pool.get_scheduler(),
                    let_done(
                        let_error(
                            let_value(
                                std::move(*itr),
                                [signal, &data, i](auto&& result) {
                                    try {
                                        data.resultStorage[i].emplace(std::move(result));
                                        signal();
                                        return just();
                                    } catch (...) {
                                        //return just_error(std::current_exception());
                                        return just();
                                    }
                                }
                            ),
                            [signal, &data](auto&& e) noexcept {
                                if (!data.doneOrError.exchange(true, std::memory_order_relaxed)) {
                                    data.error.emplace(e);
                                    // TODO - request stop
                                }
                                signal();
                                return just();
                            }
                        ) ,[signal, &data]() noexcept {
                            if (!data.doneOrError.exchange(true, std::memory_order_relaxed)) {
                                // TODO - request stop
                            }
                            signal();
                            return just();
                        }
                    )
                );
            }

            return sequence(
                data.evt.async_wait(),
                let_value(
                    let_value(data.scope.cleanup(), [&data]() {
                        bool should_send_done =
                            data.doneOrError.load(std::memory_order_relaxed) && !data.error.has_value();
                        return just_void_or_done(!should_send_done);
                    }),
                    [&data]() {
                        if (data.doneOrError.load(std::memory_order_relaxed)) {
                            if (data.error.has_value()) {
                                std::rethrow_exception(data.error.value());
                            } else {
                                assert(!"Done result not expected here");
                            }
                        } else {
                            std::vector<int> results;
                            results.reserve(data.n);
                            std::transform(
                                data.resultStorage.begin(),
                                data.resultStorage.end(),
                                std::back_inserter(results),
                                [](auto&& e) { return std::move(e.value()); });
                            return just(std::move(results));
                        }
                })
            );
        });
    };




    std::vector<decltype(make_snd())> D;
    for (size_t i = 0; i < n / block_size + 1; ++i) {
      D.emplace_back(make_snd());
    };
  
  auto results = sync_wait(when_all_iterator(D.begin(), D.end()));

#endif

  return prime_list;
}


int main(int argc, char* argv[]) {
  size_t number = 100'000'000;
  size_t block_size = 100;

  if (argc >= 2) {
    number = std::stol(argv[1]);
  }
  if (argc >= 3) {
    block_size = std::stol(argv[2]);
  }

  auto using_bool_unifex_block = timer_2(sieve_unifex_block<bool>, number, block_size * 1024);
  auto using_char_unifex_block = timer_2(sieve_unifex_block<char>, number, block_size * 1024);

  std::cout << "Time using bool unifex block: " << duration_cast<std::chrono::milliseconds>(using_bool_unifex_block).count() << "\n";
  std::cout << "Time using char unifex block: " << duration_cast<std::chrono::milliseconds>(using_char_unifex_block).count() << "\n";

  return 0;
}
