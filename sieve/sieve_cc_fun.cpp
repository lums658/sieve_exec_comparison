/**
 * @file sieve_cc_fun.cpp
 *
 * @section LICENSE
 *
 * The MIT License
 *
 * @copyright Copyright (c) 2022 TileDB, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * @section DESCRIPTION
 *
 * Demo program for concurrencpp system: sieve of Eratosthenes,
 * free function explicit coroutine version.
 *
 * The functions that are composed for the sieve are defined in
 * sieve_fun.hpp.
 *
 * The functions in this implementation are chained together by essentially
 * calling each other in a chain, but with co_await and co_return inserted
 * in that composition.  Read-only state variables are also passed in to
 * the functions that need them.  See the definition of "task" below.
 */

#include <atomic>
#include "concurrencpp/concurrencpp.h"
#include "sieve.hpp"
#include "sieve_fun.hpp"
#include "timer.hpp"

namespace cc = concurrencpp;

/**
 * Main sieve function
 *
 * @brief Generate primes from 2 to n using sieve of Eratosthenes.
 * @tparam bool_t the type to use for the "bitmap"
 * @param n upper bound of sieve
 * @param block_size how many primes to search for given a base set of primes
 */
template<class bool_t>
auto sieve_cc_block(size_t n, size_t block_size) {
    size_t sqrt_n = static_cast<size_t>(std::ceil(std::sqrt(n)));

    /* Generate base set of sqrt(n) primes to be used for subsequent sieving */
    auto first_sieve = sieve_seq<bool_t>(sqrt_n);
    std::vector<size_t> base_primes = sieve_to_primes(first_sieve);

    /* Store vector of list of primes (each list generated by separate task chain) */
    std::vector<std::shared_ptr<std::vector<size_t>>> prime_list(n / block_size + 2);
    prime_list[0] = std::make_shared<std::vector<size_t>>(base_primes);

    /**
     * Task containing chain of coroutine calls for generating primes
     * @param cc::executor_tag tells the runtime system to launch in parallel
     */
    input_body gen {};
    auto task = [&](cc::executor_tag, std::shared_ptr<cc::thread_pool_executor> executor) -> cc::result<void> {
        co_return output_body(
            co_await [&]() -> cc::lazy_result<prime_info> {
                co_return sieve_to_primes_part<bool_t>(co_await [&]() -> cc::lazy_result<part_info<bool_t>> {
                    co_return range_sieve<bool_t>(
                        co_await [&]() -> cc::lazy_result<part_info<bool_t>> {
                            co_return gen_range<bool_t>(
                                co_await [&]() -> cc::lazy_result<size_t> {
                                    co_return gen();
                                }(),
                                block_size,
                                sqrt_n,
                                n);
                        }(),
                        base_primes);
                }());
            }(),
            prime_list);
    };

    cc::runtime runtime;
    auto exec = runtime.thread_pool_executor();

    /**
     * Launch tasks, each of which computes a  block of primes
     */
    std::vector<cc::result<void>> tasks;
    for (size_t i = 0; i < n / block_size + 1; ++i) {
        tasks.push_back(task({}, exec));
    }

    /**
     * Wait for tasks to complete
     */
    for (size_t i = 0; i < n / block_size + 1; ++i) {
        tasks[i].wait();
    }

    return prime_list;
}

int main(int argc, char* argv[]) {
    size_t number = 100'000'000;
    size_t block_size = 100;

    if (argc >= 2) {
        number = std::stol(argv[1]);
    }
    if (argc >= 3) {
        block_size = std::stol(argv[2]);
    }

    auto using_bool_cc_block = timer_2(sieve_cc_block<bool>, number, block_size * 1024);
    auto using_char_cc_block = timer_2(sieve_cc_block<char>, number, block_size * 1024);

    std::cout << "Time using bool cc block: " << duration_cast<std::chrono::milliseconds>(using_bool_cc_block).count() << "\n";
    std::cout << "Time using char cc block: " << duration_cast<std::chrono::milliseconds>(using_char_cc_block).count() << "\n";

    return 0;
}
